(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.graphboard = {}));
})(this, (function (exports) { 'use strict';

	/**
	 * Create a High Definition Canvas.
	 *
	 * @param {*} canvas
	 * @returns Scaled 2d Context
	 */
	function setupHiDefCanvas(canvas) {
	  // Get the device pixel ratio, falling back to 1.
	  var devicePixelRatio = window.devicePixelRatio || 1;
	  var ctx = canvas.getContext("2d");
	  console.log("─────────────────────────");
	  console.log("│ setupHiDefCanvas      │");
	  console.log("─────────────────────────");
	  console.log("  devicePixelRatio : " + devicePixelRatio);
	  console.log("  canvas.width  : " + canvas.width);
	  console.log("  canvas.height : " + canvas.height); // Get the size of the canvas in CSS pixels.

	  var rect = canvas.getBoundingClientRect();
	  console.log("  rect.width  : " + rect.width);
	  console.log("  rect.height : " + rect.height);
	  var initialWidth = canvas.width;
	  var initialHeight = canvas.height; // On Hi Def like Retina display we double the size of the canvas

	  canvas.width = initialWidth * devicePixelRatio;
	  canvas.height = initialHeight * devicePixelRatio;
	  ctx.scale(devicePixelRatio, devicePixelRatio); // and we shrink the display size using CSS

	  canvas.style.width = initialWidth + 'px';
	  canvas.style.height = initialHeight + 'px';
	  console.log("  canvas.style.width  : " + canvas.style.width);
	  console.log("  canvas.style.height  : " + canvas.style.height);
	  console.log("  canvas.width  : " + canvas.width);
	  console.log("  canvas.height : " + canvas.height);
	  console.log(" └───────────────────────┘");
	  return ctx;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  } else if (call !== void 0) {
	    throw new TypeError("Derived constructors may only return object or undefined");
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();

	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	var Renderer = /*#__PURE__*/function () {
	  function Renderer(ctx) {
	    _classCallCheck(this, Renderer);

	    this.ctx = ctx;
	  }

	  _createClass(Renderer, [{
	    key: "drawGrid",
	    value: function drawGrid(w, h) {
	      this.ctx.save();
	      this.ctx.fillStyle = 'white';
	      this.ctx.fillRect(0, 0, w, h);
	      this.ctx.lineWidth = 0.3;
	      this.ctx.strokeStyle = 'lightgray';
	      this.ctx.fillStyle = 'black';

	      for (var i = 1; i < w; i++) {
	        this.ctx.beginPath();

	        if (i % 10 === 0) {
	          this.ctx.moveTo(i, 0);
	          this.ctx.lineTo(i, h);
	          this.ctx.moveTo(i, 0);
	        }

	        this.ctx.closePath();
	        this.ctx.stroke();
	      }

	      for (var _i = 1; _i < h; _i++) {
	        this.ctx.beginPath();

	        if (_i % 10 === 0) {
	          this.ctx.moveTo(0, _i);
	          this.ctx.lineTo(w, _i);
	          this.ctx.moveTo(0, _i);
	        }

	        this.ctx.closePath();
	        this.ctx.stroke();
	      }

	      this.ctx.lineWidth = 1;
	      this.ctx.strokeStyle = 'gray';
	      this.ctx.beginPath();

	      for (var _i2 = 50; _i2 < w; _i2 += 10) {
	        if (_i2 % 50 === 0) {
	          this.ctx.moveTo(_i2, 0);
	          this.ctx.lineTo(_i2, 30);
	          this.ctx.fillText(" ".concat(_i2), _i2, 30);
	        } else {
	          this.ctx.moveTo(_i2, 0);
	          this.ctx.lineTo(_i2, 10);
	        }
	      }

	      this.ctx.closePath();
	      this.ctx.stroke();
	      this.ctx.beginPath();

	      for (var _i3 = 50; _i3 < h; _i3 += 10) {
	        if (_i3 % 50 === 0) {
	          this.ctx.moveTo(0, _i3);
	          this.ctx.lineTo(30, _i3);
	          this.ctx.fillText(" ".concat(_i3), 30, _i3);
	        } else {
	          this.ctx.moveTo(0, _i3);
	          this.ctx.lineTo(10, _i3);
	        }
	      }

	      this.ctx.closePath();
	      this.ctx.stroke();
	      this.ctx.restore();
	    }
	  }]);

	  return Renderer;
	}();

	// =============================================================
	function to_radians(degrees) {
	  return degrees * (Math.PI / 180);
	}

	/**
	 *  A vector is an entity that has both magnitude and direction.
	 *  2D vector implementation based on the vector functions in P5.js
	 */
	var Vector = /*#__PURE__*/function () {
	  function Vector(x, y) {
	    _classCallCheck(this, Vector);

	    this.x = x || 0;
	    this.y = y || 0;

	    if (isNaN(x) || isNaN(y)) {
	      console.warn("Vector(): parameters are not number: (".concat(x, "), ").concat(y, " "));
	    }
	    /*
	    console.log("in Vector()");
	    console.log("this.x  = " + this.x);
	    console.log("this.y  = " + this.y);
	    	console.log("typeof x  = " + typeof y);
	    console.log("typeof y  = " + typeof y);
	    */

	  }

	  _createClass(Vector, [{
	    key: "add",
	    value:
	    /**
	     * Supports adding a Vector or a Scalar
	     * @param {*} n
	     * @returns
	     */
	    function add(n) {
	      if (n instanceof Vector) {
	        this.x += n.x;
	        this.y += n.y;
	        return this;
	      } else if (typeof n === "number") {
	        this.x += n;
	        this.y += n;
	        return this;
	      } else {
	        console.error("Parameter in Vector.add(n) Not supported: ".concat(n, ")"));
	      }
	    }
	    /**
	     *  Return a new vector
	     * @returns
	     */

	  }, {
	    key: "copy",
	    value: function copy() {
	      return new Vector(this.x, this.y);
	    }
	    /* divide vector length (ie magnitude) by a constant*/

	  }, {
	    key: "div",
	    value: function div(n) {
	      if (n === 0) {
	        //console.warn("Vector.div:", "divide by 0");
	        return this;
	      }

	      this.x /= n;
	      this.y /= n;
	      return this;
	    }
	  }, {
	    key: "lerp",
	    value: function lerp(v1, amount) {
	      this.x += (v1.x - this.x) * amount || 0;
	      this.y += (v1.y - this.y) * amount || 0;
	      return this;
	    }
	  }, {
	    key: "heading",
	    value: function heading() {
	      var h = Math.atan2(this.y, this.x);
	      return h;
	    }
	  }, {
	    key: "magSq",
	    value: function magSq() {
	      var x = this.x;
	      var y = this.y;
	      return x * x + y * y;
	    }
	  }, {
	    key: "mag",
	    value: function mag() {
	      return Math.sqrt(this.magSq());
	    }
	  }, {
	    key: "normalize",
	    value: function normalize() {
	      return this.div(this.mag());
	    }
	    /**
	    Multiply vector length (ie magnitude) by a constant
	    */

	  }, {
	    key: "mult",
	    value: function mult(n) {
	      this.x *= n;
	      this.y *= n;
	      return this;
	    }
	    /**
	     *  set magnitude to a given value
	     */

	  }, {
	    key: "setMag",
	    value: function setMag(n) {
	      return this.normalize().mult(n);
	    }
	    /**
	     * 
	     * @param {*} n 
	     * @returns 
	     */

	  }, {
	    key: "sub",
	    value: function sub(n) {
	      if (n instanceof Vector) {
	        this.x -= n.x;
	        this.y -= n.y;
	        return this;
	      } else if (typeof n === "number") {
	        this.x -= n;
	        this.y -= n;
	        return this;
	      } else {
	        console.error("Parameter in Vector.sub(n) Not supported: ".concat(n, ")"));
	      }
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return "[" + this.x + ", " + this.y + "]";
	    }
	  }], [{
	    key: "add",
	    value: function add(v1, v2) {
	      return new Vector(v1.x + v2.x, v1.y + v2.y);
	    }
	    /**
	     * Divides a vector by a scalar and returns a new vector.
	     *
	     * @method div
	     * @static
	     * @param  {Vector} v
	     * @param  {Number}  n
	     * @return  {Vector}
	     */

	  }, {
	    key: "div",
	    value: function div(v, n) {
	      var result = v.copy();
	      return result.div(n);
	    }
	    /**
	     * Linear interpolate the vector to another vector
	     */

	  }, {
	    key: "lerp",
	    value: function lerp(v1, v2, amount) {
	      var result = v1.copy();
	      return result.lerp(v2, amount);
	    }
	  }, {
	    key: "random",
	    value: function random(min, max) {
	      var x = randomIntBounds(min, max);
	      var y = randomIntBounds(min, max);
	      return new Vector(x, y);
	    }
	  }, {
	    key: "sub",
	    value: function sub(v1, v2) {
	      return new Vector(v1.x - v2.x, v1.y - v2.y);
	    }
	  }]);

	  return Vector;
	}();
	/* Return a random integer between min and max (inclusive) */

	function randomIntBounds(min, max) {
	  return Math.floor(Math.random() * (max - min + 1) + min);
	}

	var Link = function Link(source, target) {
	  _classCallCheck(this, Link);

	  if (source.id && target.id) {
	    this.id = source.id + " → " + target.id;
	  } else {
	    this.id = source + " → " + target;
	  }

	  this.source = source;
	  this.target = target;
	};

	var Node = /*#__PURE__*/function () {
	  function Node(id, data) {
	    _classCallCheck(this, Node);

	    this.id = id;
	    this.data = data;
	    this.level = 0;
	    this.children = [];
	    this.parent;
	    this.neighbor;
	    this.isCollapsed = false;
	    this.size = 20;
	    this.mass = 13; //(6 * this.size) / 1.5;

	    this.radius = this.size;
	    this.pos = new Vector(0, 0);
	    this.velocity = new Vector(0, 0);
	    this.acceleration = new Vector(0, 0);
	  }

	  _createClass(Node, [{
	    key: "toString",
	    value: function toString() {
	      return "Node " + this.id + "(" + this.pos.x + ", " + this.pos.y + ")";
	    }
	  }, {
	    key: "addChild",
	    value: function addChild(node) {
	      this.children.push(node);
	    }
	  }, {
	    key: "getAdjacents",
	    value: function getAdjacents() {
	      return this.children;
	    }
	  }, {
	    key: "isAdjacent",
	    value: function isAdjacent(node) {
	      return this.children.indexOf(node) > -1;
	    }
	  }, {
	    key: "getChildAt",
	    value: function getChildAt(i) {
	      return this.children[i];
	    }
	  }, {
	    key: "getFirstChild",
	    value: function getFirstChild() {
	      return this.getChildAt(0);
	    }
	  }, {
	    key: "getChildrenCount",
	    value: function getChildrenCount() {
	      return this.children.length;
	    }
	  }, {
	    key: "isLeaf",
	    value: function isLeaf() {
	      return this.children && this.children.length == 0;
	    }
	  }, {
	    key: "hasChild",
	    value: function hasChild() {
	      return this.children && this.children.length > 0;
	    }
	  }, {
	    key: "getLastChild",
	    value: function getLastChild() {
	      return this.getChildAt(this.getChildrenCount() - 1);
	    }
	  }, {
	    key: "isAncestorCollapsed",
	    value: function isAncestorCollapsed() {
	      if (this.parent == null) {
	        return false;
	      }

	      return this.parent.isCollapsed ? true : this.parent.id === -1 ? false : this.parent.isAncestorCollapsed();
	    }
	    /**
	     *  isLeftMost: is this node == to the first child of its parent?
	     */

	  }, {
	    key: "isLeftMost",
	    value: function isLeftMost() {
	      if (!this.parent || this.parent === null) {
	        return true;
	      } else {
	        return this.parent.getFirstChild() === this;
	      }
	    }
	    /**
	     *  isRightMost: is this node == to the last child of its parent?
	     */

	  }, {
	    key: "isRightMost",
	    value: function isRightMost() {
	      if (!this.parent || this.parent === null) {
	        return true;
	      } else {
	        return this.parent.getLastChild() === this;
	      }
	    }
	  }, {
	    key: "getLeftSibling",
	    value: function getLeftSibling() {
	      if (this.parent === null || this.isLeftMost()) {
	        return null;
	      } else {
	        var index = this.parent.children.indexOf(this);
	        return this.parent.children[index - 1];
	      }
	    }
	  }, {
	    key: "getRightSibling",
	    value: function getRightSibling() {
	      if (this.parent === null || this.isRightMost()) {
	        return null;
	      } else {
	        var index = this.parent.children.indexOf(this);
	        return this.parent.children[index + 1];
	      }
	    }
	  }, {
	    key: "getLeftMostChild",
	    value: function getLeftMostChild() {
	      if (this.getChildrenCount() == 0) return null;
	      return this.children[0];
	    }
	  }, {
	    key: "getRightMostChild",
	    value: function getRightMostChild() {
	      if (this.getChildrenCount() == 0) return null;
	      return this.children[this.getChildrenCount() - 1];
	    }
	  }, {
	    key: "hasLeftSibling",
	    value: function hasLeftSibling() {
	      return !this.isLeftMost();
	    }
	  }]);

	  return Node;
	}();

	var Graph = /*#__PURE__*/function () {
	  function Graph() {
	    _classCallCheck(this, Graph);

	    this.graph = {};
	    this.nodeList = [];
	    this.linkList = [];
	    this.adjacency = {};
	    this.changed = false;
	    this.root;
	  }
	  /**
	   * Add a node
	   * @param {*} node
	   * @returns
	   */


	  _createClass(Graph, [{
	    key: "addNode",
	    value: function addNode(node) {
	      if (!(node.id in this.graph)) {
	        this.nodeList.push(node);
	        this.graph[node.id] = node;
	      } else {
	        console.log("Node already exists: " + node.id);
	      }

	      return node;
	    }
	  }, {
	    key: "getNode",
	    value: function getNode(nodeID) {
	      var node = this.graph[nodeID];
	      return node;
	    }
	  }, {
	    key: "nodeAt",
	    value: function nodeAt(index) {
	      var node = this.nodeList[index];
	      return node;
	    }
	    /**
	     *  Add an object. Create a node from the specified object
	     * @param {*} object
	     * @returns
	     */

	  }, {
	    key: "addObject",
	    value: function addObject(object) {
	      var node = new Node(object.id, object);

	      if (object.parentId) {
	        node.parent = this.getNode(object.parentId);

	        if (!node.parent) {
	          console.error("Parent node not found for parentId: " + object.parentId);
	        } else {
	          node.level = node.parent.level + 1;
	          node.parent.children.push(node);
	        }
	      } else {
	        this.root = node;
	      }

	      this.addNode(node);
	      this.changed = true;
	      return node;
	    }
	  }, {
	    key: "getLinkCount",
	    value: function getLinkCount() {
	      return this.linkList.length;
	    }
	  }, {
	    key: "getNodeCount",
	    value: function getNodeCount() {
	      return this.nodeList.length;
	    }
	  }, {
	    key: "addLink",
	    value: function addLink(sourceNode_id, targetNode_id) {
	      var sourceNode = this.getNode(sourceNode_id);

	      if (sourceNode == undefined) {
	        throw new TypeError("Trying to add a link to the non-existent node with id: " + sourceNode_id);
	      }

	      var targetNode = this.getNode(targetNode_id);

	      if (targetNode == undefined) {
	        throw new TypeError("Trying to add a link to the non-existent node with id: " + targetNode_id);
	      }

	      var link = new Link(sourceNode, targetNode);
	      var exists = false;
	      this.linkList.forEach(function (item) {
	        if (link.id === item.id) {
	          exists = true;
	        }
	      });

	      if (!exists) {
	        this.linkList.push(link);
	        sourceNode.addChild(targetNode);
	      } else {
	        console.log("LINK EXIST: " + " source: " + link.source.id + " => " + link.target.id);
	      }

	      if (!(link.source.id in this.adjacency)) {
	        this.adjacency[link.source.id] = {};
	      }

	      if (!(link.target.id in this.adjacency[link.source.id])) {
	        this.adjacency[link.source.id][link.target.id] = [];
	      }

	      this.adjacency[link.source.id][link.target.id].push(link);
	    }
	  }, {
	    key: "loadJSON",
	    value: function loadJSON(json_string) {
	      var json_object = JSON.parse(json_string);
	      var nodes = json_object["nodes"];

	      for (var index = 0; index < nodes.length; index++) {
	        var node = nodes[index];
	        this.addObject(node);
	      }

	      var links = json_object["links"];

	      if (links) {
	        for (var _index = 0; _index < links.length; _index++) {
	          var link = links[_index];
	          this.addLink(link.source, link.target);
	        }
	      }

	      console.log("Graph.loadJSON ");
	      console.log(this.graph);
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return this.nodeList.map(printNode);
	    }
	  }]);

	  return Graph;
	}();

	function printNode(node) {
	  var adjacentsRepresentation = "";

	  if (node.getAdjacents() == 0) {
	    adjacentsRepresentation = "no children";
	  } else {
	    adjacentsRepresentation = node.getAdjacents().map(function (item) {
	      return item.id;
	    }).join(", ");
	  }

	  return node.id + " => " + adjacentsRepresentation;
	}

	var ForceDirected = /*#__PURE__*/function () {
	  function ForceDirected(graph, options) {
	    _classCallCheck(this, ForceDirected);

	    _defineProperty(this, "animate", function () {
	      console.log("animate");
	    });

	    this.graph = graph;
	    this.initNodes();
	    var DEFAULTS = {
	      GRAVITY: 0.9,
	      REPULSION: 500000
	    };
	    this.options = Object.assign({}, DEFAULTS, options);
	  }

	  _createClass(ForceDirected, [{
	    key: "initNodes",
	    value: function initNodes() {
	      var min = -1000;
	      var max = 1000;
	      this.graph.nodeList.forEach(function (node) {
	        node.pos = new Vector.random(min, max);
	      });
	    }
	  }, {
	    key: "run",
	    value: function run() {
	      //requestAnimationFrame(this.animate);
	      console.log("run");
	    }
	  }, {
	    key: "applyForce",
	    value:
	    /**
	     *  applyForce
	     *
	     *  Newton’s second law.
	     *  Receive a force, divide by mass, and add to acceleration.
	     */
	    function applyForce(node, force) {
	      var forceOverMass = Vector.div(force, node.mass);
	      node.acceleration.add(forceOverMass);
	    }
	  }, {
	    key: "updateNodesVelocity",
	    value: function updateNodesVelocity() {
	      this.graph.nodeList.forEach(function (node) {
	        var force_copy = node.acceleration.copy();
	        var forceOverMass = force_copy.div(node.mass); //	node.velocity.add( forceOverMass );

	        node.pos.add(forceOverMass); //	node.velocity.add(node.acceleration);
	        //	node.pos.add(node.velocity);
	        //	node.acceleration.mult(0);
	      });
	    }
	  }, {
	    key: "applyForcesTowardsCenter",
	    value: function applyForcesTowardsCenter() {
	      var _this = this;

	      // apply force towards center
	      this.graph.nodeList.forEach(function (node) {
	        var gravity = node.pos.copy().mult(-1).mult(_this.options.GRAVITY);
	        node.acceleration = gravity; //node.applyForce(gravity);
	        //console.log(node);
	      });
	    }
	  }, {
	    key: "applyRepulsiveForces",
	    value: function applyRepulsiveForces() {
	      // apply repulsive force between nodes
	      for (var i = 0; i < this.graph.nodeList.length; i++) {
	        for (var j = i + 1; j < this.graph.nodeList.length; j++) {
	          if (i != j) {
	            var node1 = this.graph.nodeList[i];
	            var node2 = this.graph.nodeList[j]; //console.log("applyRepulsiveForces");
	            //console.log(node1);
	            //console.log(node2);
	            // The gravitational force F between two bodies of mass m1 and m2 is
	            // F = G*m1*m2 / r2
	            // the vector that points from one object to the other

	            var dir = Vector.sub(node2.pos, node1.pos); // let unit = dir.copy().normalize()
	            // the length (magnitude) of that vector is the distance between the two objects.

	            var distance = dir.mag(); // The strength of the force is inversely proportional to the distance squared.
	            // The farther away an object is, the weaker the force; the closer, the stronger.
	            // original  : without the normalize

	            dir.normalize();
	            var force1 = dir.mult(this.options.REPULSION);
	            force1.div(distance * distance);
	            var inverseForce = force1.copy().mult(-1);
	            node2.acceleration.add(force1);
	            node1.acceleration.add(inverseForce); //node2.applyForce(force1);
	            //node1.applyForce(inverseForce);
	          }
	        }
	      }
	    }
	  }, {
	    key: "applyForcesExertedByConnections",
	    value: function applyForcesExertedByConnections() {
	      this.graph.linkList.forEach(function (link) {
	        var node1 = link.source;
	        var node2 = link.target; //let maxDis = con[2];
	        //let connector_length = 100;

	        var dir = Vector.sub(node1.pos, node2.pos);
	        var neg_force = new Vector(0, 0).sub(dir);
	        var pos_force = new Vector(0, 0).add(dir);
	        node1.acceleration.add(neg_force);
	        node2.acceleration.add(pos_force); //node1.applyForce(neg_force);
	        //node2.applyForce(pos_force);
	      });
	    }
	  }, {
	    key: "applyForces",
	    value: function applyForces() {
	      // Force equals mass times acceleration.
	      // Newton’s second law, F→=M×A→ (or force = mass * acceleration).
	      this.applyForcesTowardsCenter();
	      this.applyRepulsiveForces();
	      this.applyForcesExertedByConnections();
	      this.updateNodesVelocity(); // kinetic energy (KE) is equal to half of an object's mass (1/2*m) multiplied by the velocity squared.

	      /*
	      let total_KE = 0.0;
	      this.graph.nodeList.forEach((node) => {
	      	let velocity = node.velocity.mag();
	      		let node_KE = 0.5 * node.mass * (velocity * velocity);
	      	total_KE = + node_KE;
	      	});
	      console.warn("total_KE= " + total_KE);
	      */
	    }
	  }]);

	  return ForceDirected;
	}();

	var NONE = "none";

	var Shape = /*#__PURE__*/function () {
	  function Shape(x, y, type) {
	    _classCallCheck(this, Shape);

	    this.type = type;
	    this.x = x;
	    this.y = y;
	    this.isSelected = false;
	    this.strokeStyle = NONE;
	  }

	  _createClass(Shape, [{
	    key: "getColor",
	    value: function getColor() {
	      return this.color;
	    }
	  }]);

	  return Shape;
	}();

	var Arc = /*#__PURE__*/function (_Shape) {
	  _inherits(Arc, _Shape);

	  var _super = _createSuper(Arc);

	  function Arc(x, y, radius, radians) {
	    var _this;

	    _classCallCheck(this, Arc);

	    _this = _super.call(this, x, y);
	    _this.radius = radius;
	    _this.radians = radians;
	    return _this;
	  }

	  _createClass(Arc, [{
	    key: "isHit",
	    value: function isHit(x, y) {
	      var dx = this.x - x;
	      var dy = this.y - y;

	      if (dx * dx + dy * dy < this.radius * this.radius) {
	        return true;
	      }
	    }
	  }, {
	    key: "render",
	    value: function render(ctx) {
	      ctx.save();
	      ctx.beginPath();
	      ctx.arc(this.x, this.y, this.radius, 0, this.radians, false);

	      if (this.fillStyle) {
	        ctx.fillStyle = this.fillStyle;
	        ctx.fill();
	      }

	      if (this.strokeStyle != NONE) {
	        ctx.strokeStyle = this.strokeStyle;
	        ctx.lineWidth = this.lineWidth;
	        ctx.stroke();
	      }

	      ctx.restore();
	    }
	  }]);

	  return Arc;
	}(Shape);

	var Circle = /*#__PURE__*/function (_Arc) {
	  _inherits(Circle, _Arc);

	  var _super = _createSuper(Circle);

	  function Circle(x, y, radius) {
	    _classCallCheck(this, Circle);

	    return _super.call(this, x, y, radius, Math.PI * 2);
	  }

	  _createClass(Circle, [{
	    key: "isHit",
	    value: function isHit(x, y) {
	      var dx = this.x - x;
	      var dy = this.y - y;

	      if (dx * dx + dy * dy < this.radius * this.radius) {
	        return true;
	      }
	    }
	  }, {
	    key: "getBBox",
	    value: function getBBox() {
	      return {
	        x: this.x - this.radius,
	        y: this.y - this.radius,
	        width: this.radius * 2,
	        height: this.radius * 2
	      };
	    }
	  }]);

	  return Circle;
	}(Arc);

	var Rectangle = /*#__PURE__*/function (_Shape) {
	  _inherits(Rectangle, _Shape);

	  var _super = _createSuper(Rectangle);

	  function Rectangle(x, y, width, height) {
	    var _this;

	    _classCallCheck(this, Rectangle);

	    _this = _super.call(this, x, y);
	    _this.width = width;
	    _this.height = height;
	    return _this;
	  }

	  _createClass(Rectangle, [{
	    key: "getArea",
	    value: function getArea() {
	      return this.width * this.height;
	    }
	  }, {
	    key: "isHit",
	    value: function isHit(x, y) {
	      if (x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height) {
	        return true;
	      }
	    }
	  }, {
	    key: "render",
	    value: function render(ctx) {
	      ctx.save();
	      ctx.beginPath();
	      ctx.rect(this.x, this.y, this.width, this.height);

	      if (this.fillStyle) {
	        ctx.fillStyle = this.fillStyle;
	        ctx.fill();
	      }

	      if (this.strokeStyle != NONE) {
	        ctx.strokeStyle = this.strokeStyle;
	        ctx.lineWidth = this.lineWidth;
	        ctx.stroke();
	      }

	      ctx.restore();
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return "rectangle:  (".concat(this.x, ",").concat(this.y, ") x (").concat(this.width, ",").concat(this.height, ")");
	    }
	  }]);

	  return Rectangle;
	}(Shape);

	var InputDeviceTracker = /*#__PURE__*/function () {
	  function InputDeviceTracker(canvas, callback) {
	    _classCallCheck(this, InputDeviceTracker);

	    console.log("InputDeviceTracker ()");
	    this.canvas = canvas;
	    this.callback = callback; // let self = this;

	    console.log("constructor this");
	    console.log(this);
	    this.canvas.addEventListener('mousedown', this.onDown.bind(this));
	    this.canvas.addEventListener('mousemove', this.onMove.bind(this));
	    this.canvas.addEventListener('mouseup', this.onUp.bind(this));
	    this.canvas.addEventListener('touchstart', this.onDown.bind(this));
	    this.canvas.addEventListener('touchmove', this.onMove.bind(this));
	    this.canvas.addEventListener('touchend', this.onUp.bind(this));
	  }

	  _createClass(InputDeviceTracker, [{
	    key: "getCoordinatesFromEvent",
	    value: function getCoordinatesFromEvent(evt) {
	      var rect = self.canvas.getBoundingClientRect();
	      var offsetTop = rect.top;
	      var offsetLeft = rect.left;

	      if (evt.touches) {
	        return {
	          x: evt.touches[0].clientX - offsetLeft,
	          y: evt.touches[0].clientY - offsetTop
	        };
	      } else {
	        return {
	          x: evt.clientX - offsetLeft,
	          y: evt.clientY - offsetTop
	        };
	      }
	    }
	  }, {
	    key: "onDown",
	    value: function onDown(evt) {
	      evt.preventDefault();
	      var coords = this.getCoordinatesFromEvent(evt);
	      this.callback("down", coords.x, coords.y);
	    }
	  }, {
	    key: "onUp",
	    value: function onUp(evt) {
	      evt.preventDefault();
	      this.callback("up");
	    }
	  }, {
	    key: "onMove",
	    value: function onMove(evt) {
	      evt.preventDefault();
	      var coords = this.getCoordinatesFromEvent(evt);
	      this.callback("move", coords.x, coords.y);
	    }
	  }]);

	  return InputDeviceTracker;
	}();

	var MChart = /*#__PURE__*/function () {
	  function MChart(container, options) {
	    _classCallCheck(this, MChart);

	    console.log("MChart container()");
	    console.log(container);
	    this.container = container;
	    this.startX = 0, this.startY = 0;
	    this.lastMoveX = 0, this.lastMoveY = 0;
	    this.canvas = document.getElementById("canvas"); //this.ctx = this.canvas.getContext("2d");

	    this.ctx = setupHiDefCanvas(this.canvas);
	    this.cw = this.canvas.width;
	    this.ch = this.canvas.height;
	    this.renderer = new Renderer(this.ctx);
	    this.inputDeviceTracker = new InputDeviceTracker(this.canvas, this.manageInputEvents.bind(this));
	    var DEFAULTS = {
	      display_grid: false,
	      selection: {
	        strokeStyle: '#CC0000',
	        //  'rgba(255,51,0,1)', //'rgba(0,128,255,1)';
	        lineWidth: 0.5,
	        fillStyle: 'rgba(255,51,0,0.05)' //'rgba(0,128,255, 0.2)';

	      }
	    };
	    this.options = Object.assign({}, DEFAULTS, options);
	    /* The selection rectangle */

	    this.selection = new Rectangle(100, 100, 100, 100);
	    this.selection.strokeStyle = this.options.selection.strokeStyle;
	    this.selection.fillStyle = this.options.selection.fillStyle;
	    this.selection.lineWidth = this.options.selection.lineWidth;
	    /* The list of ojbects to draw */

	    this.objects = [];
	    this.isSelecting = false;
	    this.isDragging = false;
	    this.clicked_on_the_canvas = false;
	  }

	  _createClass(MChart, [{
	    key: "dump",
	    value: function dump() {
	      console.log("MChart container= ");
	      console.log("- objects= ");
	      console.log(this.objects);
	    }
	  }, {
	    key: "addObject",
	    value: function addObject(object) {
	      this.objects.push(object); //this.draw();
	    }
	    /**
	     *  Private function to render one frame. It is being called by render()
	     */
	    //renderFrame = () => {

	  }, {
	    key: "renderFrame",
	    value: function renderFrame() {
	      var _this = this;

	      // console.log("renderFrame")
	      this.ctx.clearRect(0, 0, this.cw, this.ch);

	      if (this.options.display_grid) {
	        this.renderer.drawGrid(this.cw, this.ch);
	      }

	      this.objects.forEach(function (object) {
	        object.render(_this.ctx);

	        if (object.isSelected) {
	          var selection;

	          if (object instanceof Circle) {
	            var bbox = object.getBBox();
	            selection = new Rectangle(bbox.x, bbox.y, bbox.width, bbox.height);
	          } else {
	            selection = new Rectangle(object.x, object.y, object.width, object.height);
	          }

	          selection.strokeStyle = _this.options.selection.strokeStyle;
	          selection.lineWidth = _this.options.selection.lineWidth;
	          selection.render(_this.ctx);
	        }

	        if (_this.isSelecting == true) {
	          _this.selection.render(_this.ctx);
	        }
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      this.renderFrame();
	      window.requestAnimationFrame(this.render.bind(this, this.canvas));
	    }
	  }, {
	    key: "manageInputEvents",
	    value: function manageInputEvents(evtType, x, y) {
	      var _this2 = this;

	      switch (evtType) {
	        case "down":
	          this.mouseIsDown = true;
	          this.startX = x;
	          this.startY = y;
	          this.lastMoveX = x;
	          this.lastMoveY = y;
	          /* we assume the user clicked on the canvas unless we find an object was hit */

	          this.clicked_on_the_canvas = true; // we start from last to check the shape that is on top first

	          for (var i = this.objects.length - 1; i >= 0; i--) {
	            var object = this.objects[i]; //    console.log ("checking for hit object = " + object.color);

	            if (object.isHit(x, y)) {
	              object.isSelected = true;
	              console.log("Clicked on : " + object.constructor.name + "/" + object.fillStyle);
	              moveObjectToLastPosition(this.objects, object);
	              this.clicked_on_the_canvas = false;
	              this.isSelecting = false;
	              this.isDragging = true;
	            }
	          }

	          console.log("clicked on the canvas = " + this.clicked_on_the_canvas);

	          if (this.clicked_on_the_canvas) {
	            console.log("clicked on the canvas");
	            this.selection_startX = x;
	            this.selection_startY = y;
	            /* reset selection if user clicked on the canvas */

	            this.objects.forEach(function (object) {
	              console.log("RESET object " + object.fillStyle + " is Circle ? " + (object instanceof Circle));
	              object.isSelected = false;
	            });
	          }

	          break;

	        case "up":
	          this.mouseIsDown = false;
	          console.log("MOUSE UP");
	          console.log(" isDragging : " + this.isDragging);
	          console.log(" isSelecting : " + this.isSelecting);

	          if (this.isSelecting) {
	            console.log(" selection : " + this.selection);
	            /* check if selection includes any object */

	            this.objects.forEach(function (object) {
	              if (rectContainsShape(_this2.selection, object)) {
	                object.isSelected = true;
	                console.log("object is selected: " + object.constructor.name + "/" + object.fillStyle);
	              }
	            });
	          }

	          this.isSelecting = false;
	          this.isDragging = false;
	          break;

	        case "move":
	          if (this.clicked_on_the_canvas && this.mouseIsDown) {
	            this.isSelecting = true; // getting the min & max to handle when the user selects from bottom right to top left 

	            var x1 = Math.min(this.selection_startX, this.lastMoveX);
	            var y1 = Math.min(this.selection_startY, this.lastMoveY);
	            var x2 = Math.max(this.selection_startX, this.lastMoveX);
	            var y2 = Math.max(this.selection_startY, this.lastMoveY);
	            this.selection.x = Math.floor(x1);
	            this.selection.y = Math.floor(y1);
	            this.selection.width = Math.floor(x2 - x1);
	            this.selection.height = Math.floor(y2 - y1);
	          }

	          this.lastMoveX = x;
	          this.lastMoveY = y;
	          var dx = x - this.startX;
	          var dy = y - this.startY;
	          this.startX = x;
	          this.startY = y;

	          if (this.isDragging) {
	            this.objects.forEach(function (object) {
	              if (object.isSelected) {
	                object.x += dx;
	                object.y += dy;
	              }
	            });
	          }

	          break;
	      } // this.draw();

	    }
	  }, {
	    key: "init",
	    value: function init() {
	      this.inputDeviceTracker = new InputDeviceTracker(this.canvas, this.manageInputEvents.bind(this));
	    }
	  }]);

	  return MChart;
	}();
	/**
	 *  We move the node selection to the last position so that it is drawn above the other shapes on the canvas
	 */

	function moveObjectToLastPosition(object_list, object_to_move) {
	  object_list.forEach(function (object, index) {
	    if (object === object_to_move) {
	      object_list.splice(index, 1);
	      object_list.push(object_to_move);
	      return;
	    }
	  });
	}

	function rectContainsShape(rectangle, shape) {
	  if (shape.constructor.name == "Circle") {
	    return rectContainsCircle(rectangle, shape);
	  } else if (shape.constructor.name == "Rectangle") {
	    return rectContainsRect(rectangle, shape);
	  } else {
	    console.error("rectContainsShape: shape is unknown: " + shape);
	  }
	}

	function rectContainsRect(rect1, rect2) {
	  var result_X = rect1.x < rect2.x && rect1.x + rect1.width > rect2.x + rect2.width;
	  var result_Y = rect1.y < rect2.y && rect1.y + rect1.height > rect2.y + rect2.height;
	  return result_X & result_Y;
	}

	function rectContainsCircle(rectangle, circle) {
	  // LEFT 
	  var left_include = rectangle.x < circle.x - circle.radius;

	  if (!left_include) {
	    //circle is outside of the rectangle on the left side
	    return false;
	  } // RIGHT 


	  var right_include = rectangle.x + rectangle.width > circle.x + circle.radius;

	  if (!right_include) {
	    //circle is outside of the rectangle on the right side
	    return false;
	  } // BOTTOM 


	  var bottom_include = rectangle.y + rectangle.height > circle.y + circle.radius;

	  if (!bottom_include) {
	    //circle is outside of the rectangle on the bottom side
	    return false;
	  } // TOP: 


	  var top_include = rectangle.y < circle.y - circle.radius;

	  if (!top_include) {
	    //circle is outside of the rectangle on the top side
	    return false;
	  }

	  return true;
	}

	var version = "0.1";

	exports.Arc = Arc;
	exports.Circle = Circle;
	exports.ForceDirected = ForceDirected;
	exports.Graph = Graph;
	exports.Link = Link;
	exports.MChart = MChart;
	exports.Node = Node;
	exports.Rectangle = Rectangle;
	exports.Renderer = Renderer;
	exports.Vector = Vector;
	exports.setupHiDefCanvas = setupHiDefCanvas;
	exports.to_radians = to_radians;
	exports.version = version;

}));
//# sourceMappingURL=graphboard.min.js.map
