(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.graphboard = {}));
})(this, (function (exports) { 'use strict';

  function hello(name) {
    return "hello " + name;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  var NONE = "none";

  var Shape = /*#__PURE__*/function () {
    function Shape(x, y, type) {
      _classCallCheck(this, Shape);

      this.type = type;
      this.x = x;
      this.y = y;
      this.isSelected = false;
      this.strokeStyle = NONE;
    }

    _createClass(Shape, [{
      key: "getColor",
      value: function getColor() {
        return this.color;
      }
    }]);

    return Shape;
  }();

  var Arc = /*#__PURE__*/function (_Shape) {
    _inherits(Arc, _Shape);

    var _super = _createSuper(Arc);

    function Arc(x, y, radius, radians) {
      var _this;

      _classCallCheck(this, Arc);

      _this = _super.call(this, x, y);
      _this.radius = radius;
      _this.radians = radians;
      return _this;
    }

    _createClass(Arc, [{
      key: "isHit",
      value: function isHit(x, y) {
        var dx = this.x - x;
        var dy = this.y - y;

        if (dx * dx + dy * dy < this.radius * this.radius) {
          return true;
        }
      }
    }, {
      key: "render",
      value: function render(ctx) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, this.radians, false);

        if (this.fillStyle) {
          ctx.fillStyle = this.fillStyle;
          ctx.fill();
        }

        if (this.strokeStyle != NONE) {
          ctx.strokeStyle = this.strokeStyle;
          ctx.lineWidth = this.lineWidth;
          ctx.stroke();
        }

        ctx.restore();
      }
    }]);

    return Arc;
  }(Shape);

  var Circle = /*#__PURE__*/function (_Arc) {
    _inherits(Circle, _Arc);

    var _super = _createSuper(Circle);

    function Circle(x, y, radius) {
      _classCallCheck(this, Circle);

      return _super.call(this, x, y, radius, Math.PI * 2);
    }

    _createClass(Circle, [{
      key: "isHit",
      value: function isHit(x, y) {
        var dx = this.x - x;
        var dy = this.y - y;

        if (dx * dx + dy * dy < this.radius * this.radius) {
          return true;
        }
      }
    }, {
      key: "getBBox",
      value: function getBBox() {
        return {
          x: this.x - this.radius,
          y: this.y - this.radius,
          width: this.radius * 2,
          height: this.radius * 2
        };
      }
    }]);

    return Circle;
  }(Arc);

  var Rectangle = /*#__PURE__*/function (_Shape) {
    _inherits(Rectangle, _Shape);

    var _super = _createSuper(Rectangle);

    function Rectangle(x, y, width, height) {
      var _this;

      _classCallCheck(this, Rectangle);

      _this = _super.call(this, x, y);
      _this.width = width;
      _this.height = height;
      return _this;
    }

    _createClass(Rectangle, [{
      key: "getArea",
      value: function getArea() {
        return this.width * this.height;
      }
    }, {
      key: "isHit",
      value: function isHit(x, y) {
        if (x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height) {
          return true;
        }
      }
    }, {
      key: "render",
      value: function render(ctx) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(this.x, this.y, this.width, this.height);

        if (this.fillStyle) {
          ctx.fillStyle = this.fillStyle;
          ctx.fill();
        }

        if (this.strokeStyle != NONE) {
          ctx.strokeStyle = this.strokeStyle;
          ctx.lineWidth = this.lineWidth;
          ctx.stroke();
        }

        ctx.restore();
      }
    }, {
      key: "toString",
      value: function toString() {
        return "rectangle:  (".concat(this.x, ",").concat(this.y, ") x (").concat(this.width, ",").concat(this.height, ")");
      }
    }]);

    return Rectangle;
  }(Shape);

  var InputDeviceTracker = /*#__PURE__*/function () {
    function InputDeviceTracker(canvas, callback) {
      _classCallCheck(this, InputDeviceTracker);

      console.log("InputDeviceTracker ()");
      this.canvas = canvas;
      this.callback = callback;
      self = this;
      console.log("constructor this");
      console.log(this);
      this.canvas.addEventListener('mousedown', this.onDown.bind(this));
      this.canvas.addEventListener('mousemove', this.onMove.bind(this));
      this.canvas.addEventListener('mouseup', this.onUp.bind(this));
      this.canvas.addEventListener('touchstart', this.onDown.bind(this));
      this.canvas.addEventListener('touchmove', this.onMove.bind(this));
      this.canvas.addEventListener('touchend', this.onUp.bind(this));
    }

    _createClass(InputDeviceTracker, [{
      key: "getCoordinatesFromEvent",
      value: function getCoordinatesFromEvent(evt) {
        var rect = self.canvas.getBoundingClientRect();
        var offsetTop = rect.top;
        var offsetLeft = rect.left;

        if (evt.touches) {
          return {
            x: evt.touches[0].clientX - offsetLeft,
            y: evt.touches[0].clientY - offsetTop
          };
        } else {
          return {
            x: evt.clientX - offsetLeft,
            y: evt.clientY - offsetTop
          };
        }
      }
    }, {
      key: "onDown",
      value: function onDown(evt) {
        evt.preventDefault();
        var coords = self.getCoordinatesFromEvent(evt);
        self.callback("down", coords.x, coords.y);
      }
    }, {
      key: "onUp",
      value: function onUp(evt) {
        evt.preventDefault();
        self.callback("up");
      }
    }, {
      key: "onMove",
      value: function onMove(evt) {
        evt.preventDefault();
        var coords = self.getCoordinatesFromEvent(evt);
        self.callback("move", coords.x, coords.y);
      }
    }]);

    return InputDeviceTracker;
  }();

  var Renderer = /*#__PURE__*/function () {
    function Renderer(ctx) {
      _classCallCheck(this, Renderer);

      this.ctx = ctx;
    }

    _createClass(Renderer, [{
      key: "drawGrid",
      value: function drawGrid(w, h) {
        this.ctx.save();
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(0, 0, w, h);
        this.ctx.lineWidth = 0.3;
        this.ctx.strokeStyle = 'lightgray';
        this.ctx.fillStyle = 'black';

        for (var i = 1; i < w; i++) {
          this.ctx.beginPath();

          if (i % 10 === 0) {
            this.ctx.moveTo(i, 0);
            this.ctx.lineTo(i, h);
            this.ctx.moveTo(i, 0);
          }

          this.ctx.closePath();
          this.ctx.stroke();
        }

        for (var _i = 1; _i < h; _i++) {
          this.ctx.beginPath();

          if (_i % 10 === 0) {
            this.ctx.moveTo(0, _i);
            this.ctx.lineTo(w, _i);
            this.ctx.moveTo(0, _i);
          }

          this.ctx.closePath();
          this.ctx.stroke();
        }

        this.ctx.lineWidth = 1;
        this.ctx.strokeStyle = 'gray';
        this.ctx.beginPath();

        for (var _i2 = 50; _i2 < w; _i2 += 10) {
          if (_i2 % 50 === 0) {
            this.ctx.moveTo(_i2, 0);
            this.ctx.lineTo(_i2, 30);
            this.ctx.fillText(" ".concat(_i2), _i2, 30);
          } else {
            this.ctx.moveTo(_i2, 0);
            this.ctx.lineTo(_i2, 10);
          }
        }

        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();

        for (var _i3 = 50; _i3 < h; _i3 += 10) {
          if (_i3 % 50 === 0) {
            this.ctx.moveTo(0, _i3);
            this.ctx.lineTo(30, _i3);
            this.ctx.fillText(" ".concat(_i3), 30, _i3);
          } else {
            this.ctx.moveTo(0, _i3);
            this.ctx.lineTo(10, _i3);
          }
        }

        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.restore();
      }
    }]);

    return Renderer;
  }();

  var MChart = /*#__PURE__*/function () {
    function MChart(container, options) {
      _classCallCheck(this, MChart);

      console.log("MChart container()");
      console.log(container);
      this.container = container;
      this.startX = 0, this.startY = 0;
      this.lastMoveX = 0, this.lastMoveY = 0;
      this.canvas = document.getElementById("canvas");
      this.ctx = this.canvas.getContext("2d"); //let w = canvas.width = canvas2.width = window.innerWidth * 0.9;
      //let h = canvas.height = canvas2.height = window.innerHeight * 0.9;

      this.w = this.canvas.width = window.innerWidth;
      this.h = this.canvas.height = window.innerHeight;
      this.renderer = new Renderer(this.ctx);
      var DEFAULTS = {
        display_grid: false,
        selection: {
          strokeStyle: '#CC0000',
          //  'rgba(255,51,0,1)', //'rgba(0,128,255,1)';
          lineWidth: 1,
          fillStyle: 'rgba(255,51,0,0.01)' //'rgba(0,128,255, 0.2)';

        }
      };
      this.options = Object.assign({}, DEFAULTS, options);
      /* The selection rectangle */

      this.selection = new Rectangle(100, 100, 100, 100);
      this.selection.strokeStyle = this.options.selection.strokeStyle;
      this.selection.fillStyle = this.options.selection.fillStyle;
      this.selection.lineWidth = this.options.selection.lineWidth;
      /* The list of ojbects to draw */

      this.objects = [];
      this.isSelecting = false;
      this.isDragging = false;
      this.clicked_on_the_canvas = false;
    }

    _createClass(MChart, [{
      key: "dump",
      value: function dump() {
        console.log("MChart container= ");
        console.log("- objects= ");
        console.log(this.objects);
      }
    }, {
      key: "addObject",
      value: function addObject(object) {
        this.objects.push(object);
        this.draw();
      }
    }, {
      key: "draw",
      value: function draw() {
        var _this = this;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.options.display_grid) {
          this.renderer.drawGrid(this.w, this.h);
        }

        this.objects.forEach(function (object) {
          object.render(_this.ctx);

          if (object.isSelected) {
            var selection;

            if (object instanceof Circle) {
              var bbox = object.getBBox();
              selection = new Rectangle(bbox.x, bbox.y, bbox.width, bbox.height);
            } else {
              selection = new Rectangle(object.x, object.y, object.width, object.height);
            }

            selection.strokeStyle = _this.options.selection.strokeStyle;
            selection.lineWidth = _this.options.selection.lineWidth;
            selection.render(_this.ctx);
          }

          if (_this.isSelecting == true) {
            _this.selection.render(_this.ctx);
          }
        });
      }
    }, {
      key: "manageInputEvents",
      value: function manageInputEvents(evtType, x, y) {
        var _this2 = this;

        switch (evtType) {
          case "down":
            this.mouseIsDown = true;
            this.startX = x;
            this.startY = y;
            this.lastMoveX = x;
            this.lastMoveY = y;
            /* we assume the user clicked on the canvas unless we find an object was hit */

            this.clicked_on_the_canvas = true; // we start from last to check the shape that is on top first

            for (var i = this.objects.length - 1; i >= 0; i--) {
              var object = this.objects[i]; //    console.log ("checking for hit object = " + object.color);

              if (object.isHit(x, y)) {
                object.isSelected = true;
                console.log("Clicked on : " + object.constructor.name + "/" + object.fillStyle);
                moveObjectToLastPosition(this.objects, object);
                this.clicked_on_the_canvas = false;
                this.isSelecting = false;
                this.isDragging = true;
              }
            }

            console.log("clicked on the canvas = " + this.clicked_on_the_canvas);

            if (this.clicked_on_the_canvas) {
              console.log("clicked on the canvas");
              this.selection_startX = x;
              this.selection_startY = y;
              /* reset selection if user clicked on the canvas */

              this.objects.forEach(function (object) {
                console.log("RESET object " + object.fillStyle + " is Circle ? " + (object instanceof Circle));
                object.isSelected = false;
              });
            }

            break;

          case "up":
            this.mouseIsDown = false;
            console.log("MOUSE UP");
            console.log(" isDragging : " + this.isDragging);
            console.log(" isSelecting : " + this.isSelecting);

            if (this.isSelecting) {
              console.log(" selection : " + this.selection);
              /* check if selection includes any object */

              this.objects.forEach(function (object) {
                if (rectContainsShape(_this2.selection, object)) {
                  object.isSelected = true;
                  console.log("object is selected: " + object.constructor.name + "/" + object.fillStyle);
                }
              });
            }

            this.isSelecting = false;
            this.isDragging = false;
            break;

          case "move":
            if (this.clicked_on_the_canvas && this.mouseIsDown) {
              this.isSelecting = true; // getting the min & max to handle when the user selects going up

              var x1 = Math.min(this.selection_startX, this.lastMoveX);
              var y1 = Math.min(this.selection_startY, this.lastMoveY);
              var x2 = Math.max(this.selection_startX, this.lastMoveX);
              var y2 = Math.max(this.selection_startY, this.lastMoveY);
              this.selection.x = Math.floor(x1);
              this.selection.y = Math.floor(y1);
              this.selection.width = Math.floor(x2 - x1);
              this.selection.height = Math.floor(y2 - y1);
            }

            this.lastMoveX = x;
            this.lastMoveY = y;
            var dx = x - this.startX;
            var dy = y - this.startY;
            this.startX = x;
            this.startY = y;

            if (this.isDragging) {
              this.objects.forEach(function (object) {
                if (object.isSelected) {
                  object.x += dx;
                  object.y += dy;
                }
              });
            }

            break;
        }

        this.draw();
      }
    }, {
      key: "init",
      value: function init() {
        this.inputDeviceTracker = new InputDeviceTracker(this.canvas, this.manageInputEvents.bind(this));
      }
    }]);

    return MChart;
  }();
  /**
   *  We move the node selection to the last position so that it is drawn above the other shapes on the canvas
   */

  function moveObjectToLastPosition(object_list, object_to_move) {
    object_list.forEach(function (object, index) {
      if (object === object_to_move) {
        object_list.splice(index, 1);
        object_list.push(object_to_move);
        return;
      }
    });
  }

  function rectContainsShape(rectangle, shape) {
    if (shape.constructor.name == "Circle") {
      return rectContainsCircle(rectangle, shape);
    } else if (shape.constructor.name == "Rectangle") {
      return rectContainsRect(rectangle, shape);
    } else {
      console.error("rectContainsShape: shape is unknown: " + shape);
    }
  }

  function rectContainsRect(rect1, rect2) {
    var result_X = rect1.x < rect2.x && rect1.x + rect1.width > rect2.x + rect2.width;
    var result_Y = rect1.y < rect2.y && rect1.y + rect1.height > rect2.y + rect2.height;
    return result_X & result_Y;
  }

  function rectContainsCircle(rectangle, circle) {
    // LEFT 
    var left_include = rectangle.x < circle.x - circle.radius;

    if (!left_include) {
      //circle is outside of the rectangle on the left side
      return false;
    } // RIGHT 


    var right_include = rectangle.x + rectangle.width > circle.x + circle.radius;

    if (!right_include) {
      //circle is outside of the rectangle on the right side
      return false;
    } // BOTTOM 


    var bottom_include = rectangle.y + rectangle.height > circle.y + circle.radius;

    if (!bottom_include) {
      //circle is outside of the rectangle on the bottom side
      return false;
    } // TOP: 


    var top_include = rectangle.y < circle.y - circle.radius;

    if (!top_include) {
      //circle is outside of the rectangle on the top side
      return false;
    }

    return true;
  }

  /**
   *  A vector is an entity that has both magnitude and direction.
   *  2D vector implementation based on the vector functions in P5.js
   */
  var Vector = /*#__PURE__*/function () {
    function Vector(x, y) {
      _classCallCheck(this, Vector);

      this.x = x || 0;
      this.y = y || 0;

      if (isNaN(x) || isNaN(y)) {
        console.warn("Vector(): parameters are not number: (".concat(x, "), ").concat(y, " "));
      }
      /*
      console.log("in Vector()");
      console.log("this.x  = " + this.x);
      console.log("this.y  = " + this.y);
      	console.log("typeof x  = " + typeof y);
      console.log("typeof y  = " + typeof y);
      */

    }

    _createClass(Vector, [{
      key: "add",
      value:
      /**
       * Supports adding a Vector or a Scalar
       * @param {*} n
       * @returns
       */
      function add(n) {
        if (n instanceof Vector) {
          this.x += n.x;
          this.y += n.y;
          return this;
        } else if (typeof n === "number") {
          this.x += n;
          this.y += n;
          return this;
        } else {
          console.error("Parameter in Vector.add(n) Not supported: ".concat(n, ")"));
        }
      }
      /**
       *  Return a new vector
       * @returns
       */

    }, {
      key: "copy",
      value: function copy() {
        return new Vector(this.x, this.y);
      }
      /* divide vector length (ie magnitude) by a constant*/

    }, {
      key: "div",
      value: function div(n) {
        if (n === 0) {
          //console.warn("Vector.div:", "divide by 0");
          return this;
        }

        this.x /= n;
        this.y /= n;
        return this;
      }
    }, {
      key: "lerp",
      value: function lerp(v1, amount) {
        this.x += (v1.x - this.x) * amount || 0;
        this.y += (v1.y - this.y) * amount || 0;
        return this;
      }
    }, {
      key: "heading",
      value: function heading() {
        var h = Math.atan2(this.y, this.x);
        return h;
      }
    }, {
      key: "magSq",
      value: function magSq() {
        var x = this.x;
        var y = this.y;
        return x * x + y * y;
      }
    }, {
      key: "mag",
      value: function mag() {
        return Math.sqrt(this.magSq());
      }
    }, {
      key: "normalize",
      value: function normalize() {
        return this.div(this.mag());
      }
      /**
      Multiply vector length (ie magnitude) by a constant
      */

    }, {
      key: "mult",
      value: function mult(n) {
        this.x *= n;
        this.y *= n;
        return this;
      }
      /**
       *  set magnitude to a given value
       */

    }, {
      key: "setMag",
      value: function setMag(n) {
        return this.normalize().mult(n);
      }
      /**
       * 
       * @param {*} n 
       * @returns 
       */

    }, {
      key: "sub",
      value: function sub(n) {
        if (n instanceof Vector) {
          this.x -= n.x;
          this.y -= n.y;
          return this;
        } else if (typeof n === "number") {
          this.x -= n;
          this.y -= n;
          return this;
        } else {
          console.error("Parameter in Vector.sub(n) Not supported: ".concat(n, ")"));
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return "[" + this.x + ", " + this.y + "]";
      }
    }], [{
      key: "add",
      value: function add(v1, v2) {
        return new Vector(v1.x + v2.x, v1.y + v2.y);
      }
      /**
       * Divides a vector by a scalar and returns a new vector.
       *
       * @method div
       * @static
       * @param  {Vector} v
       * @param  {Number}  n
       * @return  {Vector}
       */

    }, {
      key: "div",
      value: function div(v, n) {
        var result = v.copy();
        return result.div(n);
      }
      /**
       * Linear interpolate the vector to another vector
       */

    }, {
      key: "lerp",
      value: function lerp(v1, v2, amount) {
        var result = v1.copy();
        return result.lerp(v2, amount);
      }
    }, {
      key: "random",
      value: function random(min, max) {
        var x = randomIntBounds(min, max);
        var y = randomIntBounds(min, max);
        return new Vector(x, y);
      }
    }, {
      key: "sub",
      value: function sub(v1, v2) {
        return new Vector(v1.x - v2.x, v1.y - v2.y);
      }
    }]);

    return Vector;
  }();
  /* Return a random integer between min and max (inclusive) */

  function randomIntBounds(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }

  var version = "0.1";

  exports.Arc = Arc;
  exports.Circle = Circle;
  exports.MChart = MChart;
  exports.Rectangle = Rectangle;
  exports.Vector = Vector;
  exports.hello = hello;
  exports.version = version;

}));
//# sourceMappingURL=graphboard.min.js.map
