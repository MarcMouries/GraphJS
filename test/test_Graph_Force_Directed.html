<html>

<head>
  <link rel="stylesheet" href="./style.css">
  <script src="../dist/umd/graphboard.min.js"></script>
  <style>
    canvas {
      border: 1px solid red;
    }
  </style>

<body>
  <canvas class="canvas" width="800" height="800"></canvas>

</body>
<script>
  const canvas = document.querySelector("canvas");
  const ctx = canvas.getContext("2d");
  var width = canvas.width;
  var height = canvas.height;
  const CENTER = { x: width / 2, y: height / 2 };

  const PI_2 = Math.PI * 2;
  const MAX_DISTANCE = 500; // not used
  const node_radius = 20;


  let graph = new graphboard.Graph();

  //let nodes = [];
  //let link_list = [];

 
  class Node {
    constructor(id, pos, size) {
      this.id = id;
      this.mass = (PI_2 * size) / 1.5;
      this.radius = size;

      this.pos = pos;
      this.force = new graphboard.Vector(0, 0);

      this.velocity = new graphboard.Vector(0, 0);
      this.acceleration = new graphboard.Vector(0, 0);
    }
    draw(ctx) {
      ctx.beginPath();
      ctx.fillStyle = "darkGrey";
      ctx.arc(this.pos.x, this.pos.y, this.radius, 0, PI_2, false);
      ctx.fill();
      ctx.closePath();
      ctx.fillStyle = "black";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(this.id, this.pos.x, this.pos.y);
    }

    /**
     *  applyForce
     *
     *  Newton’s second law.
     *  Receive a force, divide by mass, and add to acceleration.
    */
    __applyForce(force) {
      let f = Vector.div(force, this.mass);
      this.acceleration.add(f);
    }

    update() {

      let force_copy = this.force.copy();
      let velocity = force_copy.div(this.mass);
      this.pos.add(velocity);
      /*
            this.velocity.add(this.acceleration);
            this.pos.add(this.velocity);
            this.acceleration.mult(0);
            */
    }

    toString() {
      return "[" + this.id + ", " + this.pos.x + ", " + this.pos.y + "]";
    }
  }


  class ForceDirected {
    constructor(graph) {

      this.GRAVITY = 2;//0.9;
      this.REPULSION = 500000;
      this.graph = graph;

    }
    applyForcesTowardsCenter() {
      // apply force towards center
      this.graph.nodeList.forEach((node) => {
        let gravity = node.pos.copy().mult(-1).mult(this.GRAVITY);
        node.force = gravity;
        //node.applyForce(gravity);
        //console.log(node);
      });
    }

    applyRepulsiveForces() {
      // apply repulsive force between nodes
      for (let i = 0; i < graph.nodeList.length; i++) {
        for (let j = i + 1; j < graph.nodeList.length; j++) {
          if (i != j) {
            let node1 = graph.nodeList[i];
            let node2 = graph.nodeList[j];

            // The gravitational force F between two bodies of mass m1 and m2 is
            // F = G*m1*m2 / r2
            // the vector that points from one object to the other
            let dir = graphboard.Vector.sub(node2.pos, node1.pos);
            let unit = dir.copy().normalize()

            // the length (magnitude) of that vector is the distance between the two objects.
            let distance = dir.mag();

            // The strength of the force is inversely proportional to the distance squared.
            // The farther away an object is, the weaker the force; the closer, the stronger.

            // original  : without the normalize
            dir.normalize()

            let force1 = dir.mult(this.REPULSION);
            force1.div(distance * distance);

            let inverseForce = force1.copy().mult(-1);
            node2.force.add(force1);
            node1.force.add(inverseForce);
          }
        }
      }
    }

    applyForcesExertedByConnections() {
      graph.linkList.forEach((con) => {
        let node1 = graph.nodeList[con[0]];
        let node2 = graph.nodeList[con[1]];
        let maxDis = con[2];

        let dir = graphboard.Vector.sub(node1.pos, node2.pos);

        let neg_force = new graphboard.Vector(0, 0).sub(dir);
        let pos_force = new graphboard.Vector(0, 0).add(dir);

        node1.force.add(neg_force);
        node2.force.add(pos_force);
      });
    }

  }

  var layout;
  new ForceDirected(graph);



  function setup() {

    ctx.translate(width / 2, height / 2);

    /* we may want to have distinct min, max values for x and y */
    let min = -width;
    let max = 2 * width;

    let size = 15;
    let node;


    let pos1 = new graphboard.Vector.random(min, max);
    node = new Node("1", pos1, size); graph.nodeList.push(node);


    let pos2 = new graphboard.Vector.random(min, max);
    node = new Node("1_1", pos2, size); graph.nodeList.push(node);

    let pos3 = new graphboard.Vector.random(min, max);
    node = new Node("1_2", pos3, size); graph.nodeList.push(node);

    let pos4 = new graphboard.Vector.random(min, max);
    node = new Node("1_3", pos4, size); graph.nodeList.push(node);

    let pos5 = new graphboard.Vector.random(min, max);
    node = new Node("1_4", pos5, size); graph.nodeList.push(node);

    let pos6 = new graphboard.Vector.random(min, max);
    node = new Node("2_1_4", pos6, size); graph.nodeList.push(node);

    let pos7 = new graphboard.Vector.random(min, max);
    node = new Node("3", pos7, size); graph.nodeList.push(node);

    let pos8 = new graphboard.Vector.random(min, max);
    node = new Node("4", pos8, size); graph.nodeList.push(node);

    graph.linkList.push([0, 1, MAX_DISTANCE]);
    graph.linkList.push([0, 2, MAX_DISTANCE]);
    graph.linkList.push([0, 3, MAX_DISTANCE]);
    graph.linkList.push([0, 4, MAX_DISTANCE]);
    graph.linkList.push([4, 5, MAX_DISTANCE]);


    layout = new ForceDirected(graph);

  }


  function clear() {
    ctx.fillStyle = "rgba(234, 236, 238, 0.9)";
    // change origin due to translation
    ctx.fillRect(-width, -height, 2 * width, 2 * height);
  };


  function draw_line(v1, v2) {
    ctx.beginPath();
    ctx.moveTo(v1.x, v1.y);
    ctx.lineTo(v2.x, v2.y);
    ctx.strokeStyle = "rgba(50, 50, 50, 1)";

    ctx.stroke();
    ctx.closePath();
  }

  function draw_links() {
    graph.linkList.forEach((con) => {
      node1 = graph.nodeList[con[0]];
      node2 = graph.nodeList[con[1]];
      draw_line(node1.pos, node2.pos);
    });
  }




  function applyForces() {

    // Force equals mass times acceleration.
    // Newton’s second law, F→=M×A→ (or force = mass * acceleration).
    layout.applyForcesTowardsCenter();

    layout.applyRepulsiveForces();

    layout.applyForcesExertedByConnections();



    // kinetic energy (KE) is equal to half of an object's mass (1/2*m) multiplied by the velocity squared.
    let total_KE = 0.0;
    /*
    nodes.forEach((node) => {
      let node_KE = (0.5 * node.mass * node.velocity * node.velocity);
      total_KE =+  node_KE;
      });
      console.log("total_KE=" + total_KE);
  */
  }

  function loop() {

    clear();

    draw_links();

    applyForces();

    graph.nodeList.forEach((node) => {
      node.draw(ctx);
      node.update();
    });

    if (i < max_iterations) {
      requestAnimationFrame(loop);
      i++;
    }
  };

  var i = 0;
  const max_iterations = 100;
  setup();
  loop();

</script>