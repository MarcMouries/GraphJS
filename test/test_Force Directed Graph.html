<html>
<head>

	<link rel="stylesheet" href="./style.css">
    <script src="../dist/umd/graphboard.min.js"></script>
<body>
    <canvas class="canvas" width="800" height="800" ></canvas>

</body>
<script>
const canvas = document.querySelector("canvas");
const ctx = canvas.getContext("2d");
var width = canvas.width;
var height = canvas.height;
const CENTER = { x: width / 2, y: height / 2 };

const PI_2 = Math.PI * 2;
const link_distance = 100;
const node_radius = 20;
const gravity = 0.5;

var noNodes = 8;
var noConn = 2;
var gravityConstant = 0.9;
var forceConstant = 1000;

let nodes = [];
let nodeCon = [];

 nodes = [];
 /*
  { id: "1" },
  { id: "1_1" },
  { id: "1_2" },
  { id: "1_3" },
  { id: "1_4" }
];*/
 links = [
  { source: "1", target: "1_1" },
  { source: "1", target: "1_2" },
  { source: "1", target: "1_3" },
  { source: "1", target: "1_4" }
];

class Node {
  constructor(id, pos, size) {
    this.id = id;
    this.pos = pos;
    this.force = new graphboard.Vector(0, 0);
    this.mass = (PI_2 * size) / 1.5;
    this.radius = size;
    
  }
  draw(ctx) {
    ctx.beginPath();
    ctx.fillStyle = "darkGrey";
    ctx.arc(this.pos.x, this.pos.y, this.radius, 0, PI_2, false);
    ctx.fill();
    ctx.closePath();
    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(this.id, this.pos.x, this.pos.y);
  }
  update() {
    force = this.force.copy();
    let vel = force.copy().div(this.mass);
    // print("VEL", vel, "FORCE", force)
    this.pos.add(vel);
  }
}

function randomBounds(min, max) {
  return Math.random () * (max - min) + min;
}

function setup() {
  let x = randomBounds(-10 * height, 10 * height);
  let y = randomBounds(-10 * height, 10 * height);
  console.log(x);
  console.log(y);

  let size = 5;
  let pos = new graphboard.Vector(x, y);
  console.log("pos = " + pos.toString());
  console.log(pos);


  let node;
  node = new Node("1", pos, size);    nodes.push(node);
  node = new Node("1_1", pos, size);  nodes.push(node);
  node = new Node("1_2", pos, size);  nodes.push(node);
  node = new Node("1_3", pos, size);  nodes.push(node);
  node = new Node("1_4", pos, size);  nodes.push(node);

  nodeCon.push([0, 1, 500]);
  nodeCon.push([0, 2, 500]);
  nodeCon.push([0, 3, 500]);
  nodeCon.push([0, 4, 500]);
}

function clear ()  {
  ctx.fillStyle = "rgba(255, 255, 255, 1)";
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
};

function draw_line (v1, v2) {
    ctx.beginPath();
    ctx.moveTo(v1.x, v1.y);
    ctx.lineTo(v2.x, v2.y);
    ctx.stroke();
    ctx.closePath();
}

function draw_links() {
  nodeCon.forEach((con) => {
    node1 = nodes[con[0]];
    node2 = nodes[con[1]];
    draw_line(node1.pos, node2.pos);
  });
}

function applyForces(nodes) {
  // apply force towards centre
  nodes.forEach((node) => {
    let gravity = node.pos.copy().mult(-1).mult(gravityConstant);
    node.force = gravity;
  });

  // apply repulsive force between nodes
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      pos = nodes[i].pos;
      dir = nodes[j].pos.copy().sub(pos);
      force = dir.div(dir.mag() * dir.mag());
      force.mult(forceConstant);
      nodes[i].force.add(force.copy().mult(-1));
      nodes[j].force.add(force);
    }
  }

  // apply forces applied by connections
  nodeCon.forEach((con) => {
    let node1 = nodes[con[0]];
    let node2 = nodes[con[1]];
    let maxDis = con[2];
    let dis = node1.pos.copy().sub(node2.pos);
    diff = dis.mag() - maxDis;
    node1.force.sub(dis);
    node2.force.add(dis);
  });
}

function loop() {
  clear();
    //translate(width / 2, height / 2);
    draw_links();

/*
    applyForces(nodes);
  nodes.forEach((node) => {
    node.draw(ctx);
    node.update();
  });
*/
 // requestAnimationFrame(loop);
};


let v1 = new graphboard.Vector(3, 4);
console.log("v1 = " + v1.toString());
console.log(v1);


setup();

//console.log("node 0 = " + nodes[0].pos.toString());

loop();
</script>